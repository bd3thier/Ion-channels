---
title: "Kalman filter tests"
author: "Berenice"
date: "April 27, 2020"
output: html_document
---


## Apply Kalman filter - change Q and H 



```{r}
# Load packages
library(tidyverse)
library(xts)
library(dygraphs)
library(KFAS)
library(ggplot2)
library(plotly)
library(seewave)
library(signal)
library(reticulate)
use_python("C:/Users/beren/anaconda3/envs/TensorFlow-GPU")
use_virtualenv ('C:/Users/beren/Ion-channel/notebooks/R code/.env')

theme_set(theme_light())
```
```{python}
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import scipy.stats as stats
import seaborn as sns
from scipy.signal import find_peaks
from sklearn import metrics
```

## Identify peaks
We need to create to functions:

* set_param_find_peaks:
We want to use scipy "find_peaks" and detect all the peaks corresponding to an open channel (even if that means having a lot of noise), so the highest Recall. For that, we can tune height, threshold, distance, prominence, width, relative height and plateau size arguments.

* find_peaks_signal:
Once we have found the best parameters, we want to export the list of peak as a feature of train and test datasets (bool, True when a peak is detected).

```{python}
# Function to find peaks and return accuracy
from scipy.signal import find_peaks

def set_param_find_peaks(df, signal, channel_array, height=None, threshold=None, distance=None, 
                         prominence=None, width=None, wlen=None, rel_height=0.5, plateau_size=None):
    # find peaks with given parameters
    x = signal
    peaks, properties = find_peaks(x, height=height, threshold=threshold, distance=distance,  
                                  prominence=prominence, width=width, wlen=wlen, rel_height=rel_height, 
                                  plateau_size=plateau_size)
    plt.plot(x)
    plt.plot(peaks, x[peaks], "x")
    plt.plot(np.zeros_like(x), "--", color="gray")
    plt.show()
    print('Number of peaks found:', len(peaks))
    
    #Assess if all peaks have been found
    df['peak_detected']= pd.Index(range(0,len(df))).isin(peaks)
    df['is_channel_open'] = channel_array.astype(int) != 0
    detected = df.peak_detected.sum()
    open_channels = df.is_channel_open.sum()
    print('actual open channels:', open_channels)
    
    metrics.roc_auc_score(df['is_channel_open'], df['peak_detected'])
    conf_matr = metrics.confusion_matrix(df['is_channel_open'], df['peak_detected'])

    tn, fp, fn, tp = conf_matr.ravel()
    print('False positives:', fp) 
    print('True positives:', tp) 
    print('Precision:', np.round(100*tp /(tp+fp), 2), '%')
    print('False negatives:', fn) 
    print('True negatives:', tn) 
    print('Recall:', np.round(100*tp /(tp+fn), 2), '%')
    
    return df, tn, fp, fn, tp

```

```{python}
# Function to find peaks: adds a 'peak_detected' column to the dataframe with bool

def find_peaks_signal(df, signal, height=None, threshold=None, distance=None, prominence=None,
                      width=None, wlen=None, rel_height=0.5, plateau_size=None):
    x = signal
    peaks, properties = find_peaks(x, height=height, threshold=threshold, distance=distance, 
                                   prominence=prominence, width=width, wlen=wlen, rel_height=rel_height,
                                   plateau_size=plateau_size)
    df['peak_detected']= 0
    df['peak_detected']= pd.Index(range(0,len(df))).isin(peaks)
    return df.head()

```


## Apply Kalman filter

```{r}
#Read in the training data

train <- read_csv('C:/Users/beren/Ion-channel/data/external/train_clean.csv')
test <- read_csv('C:/Users/beren/Ion-channel/data/external/test_clean.csv')
trainKF_download <- read_csv('C:/Users/beren/Ion-channel/data/external/train_kalman.csv')
testKF_download <- read_csv('C:/Users/beren/Ion-channel/data/external/test_kalman.csv')

```

We can tweak parameters Q and H. I did not save all the attempts.

```{r}
#Function for applying kalman filter
kf_smooth <- function(signal, Q, H) {
  kf <- SSModel(signal ~ SSMtrend(1, Q = Q), H = H)
  out <- KFS(kf)
  alphahat <- out$alphahat
  return(alphahat)
}

#Apply KF
trainKF <- train
testKF <- test
trainKF <- train %>%  mutate(
  alphahat = kf_smooth(signal, Q = 0.1, H = 0.1)
) %>% select(time, signal = alphahat, open_channels)
testKF <- test %>%  mutate(
  alphahat = kf_smooth(signal, Q = 0.001, H = 0.1)
) %>% select(time, signal = alphahat)

```

## Make plots


```{r}
fx_plot <- function(df, sample_start = 0, sample_stop = nrow(df), subsample=1){
  data <-
          df %>%
                  mutate(sample = row_number()) %>%
                  dplyr::filter(sample %in% seq(sample_start, sample_stop, subsample))

  plot <-
          data %>%
                  ggplot() +
                  geom_line(aes(sample, signal, col = 'signal')) +
                  geom_line(aes(sample, open_channels)) 

  
  return(plot)
}


```


```{r}
start = 100000
stop = 200000
ggplotly(fx_plot(train, start,stop, 1) )

ggplotly(fx_plot(trainKF, start,stop, 1))
ggplotly(fx_plot(trainKF_download, start,stop, 1))


```

Based on this preliminary analysis, the dataset with Klaman filters downloaded from [michaln](https://www.kaggle.com/michaln/data-without-drift-with-kalman-filter) could have even less noise, but with the current settings (Q = 0.001, H = 0.1) we are missing a few peaks. We will test different Hs and Qs and use scipy.find_peak on the new signal. We will then check the accuracy of the peaks detected (do they match an open channel).

## Remove line noise with notch filter

We want to plot the FFT to visualize the Fourier transform before/after notch filter.

```{r}

plot_fft <- function(signal, fs){
  y <- fft(signal)
  y.tmp <- Mod(y)   
  y.ampspec <- y.tmp[1:(length(y)/2+1)]
  y.ampspec[2:(length(y)/2)] <- y.ampspec[2:(length(y)/2)] * 2
  f <- seq(from=0, to=fs/2, length=length(y)/2+1)
  p <- plot(f, y.ampspec, type="h", xlab="Frequency (Hz)", ylab="Amplitude Spectrum", xlim=c(0, 500), ylim=c(0, 150000))
  
  return(p)
}

notch_filt <- function(signal, from = 49.9, to=50.1, fs){
  # notch filter to remove 50 Hz electrical noise from ion channel signal
  p1 <- plot_fft(signal, fs)
  p1
  signal_filt <- bwfilter(signal, 10000, from= from, to = to, bandpass = NULL)
  p2 <- plot_fft(signal_filt, fs)
  p2
  return(signal_filt)
}

```

```{r}
trainKF$signal <- notch_filt(trainKF$signal, 49.9, 50.1, 10000)
```

```{r}
write.csv(trainKF,"../data/interim/trainKF.csv", row.names = FALSE)
```



```{python}
import pandas as pd
pd_trainKF = pd.read_csv("../data/interim/trainKF.csv")
pd_trainKF.head()
```


```{python}
pd_trainKF, tn, fp, fn, tp = set_param_find_peaks(pd_trainKF, pd_trainKF.signal, pd_trainKF.open_channels,
                                                  height=-3, threshold=None, distance=None, prominence=0.05,
                                                  width=None, wlen=None, rel_height=0.5, plateau_size=None)
```



```{r}
trainKF <- train %>%  mutate(
  alphahat = kf_smooth(signal, Q = 0.1, H = 1)
) %>% select(time, signal = alphahat, open_channels)
```

```{r}
start = 0
stop = 200000
ggplotly(fx_plot(trainKF, start,stop, 1))

```

```{r}
trainKF$signal <- notch_filt(trainKF$signal, 49.9, 50.1, 10000)
```

```{r}
write.csv(trainKF,"../data/interim/trainKF.csv", row.names = FALSE)
```

```{python}
import pandas as pd
pd_trainKF = pd.read_csv("../data/interim/trainKF.csv")
pd_trainKF.head()
```

```{python}
pd_trainKF, tn, fp, fn, tp = set_param_find_peaks(pd_trainKF, pd_trainKF.signal, pd_trainKF.open_channels,
                                                  height=-2.2, threshold=-2.2, distance=None, prominence=0.01,
                                                  width=None, wlen=None, rel_height=0.5, plateau_size=None)
```
```{r}
testKF <- test %>%  mutate(
  alphahat = kf_smooth(signal, Q = 0.1, H = 1)
) %>% select(time, signal = alphahat)
```

```{r}
testKF$signal <- notch_filt(testKF$signal, 49.9, 50.1, 10000)
```

```{r}
write.csv(testKF,"../data/interim/testKF.csv", row.names = FALSE)
```

